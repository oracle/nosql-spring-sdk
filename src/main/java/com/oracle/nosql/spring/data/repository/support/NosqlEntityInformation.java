/*-
 * Copyright (c) 2020, 2023 Oracle and/or its affiliates.  All rights reserved.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 *  https://oss.oracle.com/licenses/upl/
 */
package com.oracle.nosql.spring.data.repository.support;

import com.oracle.nosql.spring.data.Constants;
import com.oracle.nosql.spring.data.NosqlDbFactory;
import com.oracle.nosql.spring.data.core.NosqlTemplateBase;
import com.oracle.nosql.spring.data.core.mapping.NosqlCapacityMode;
import com.oracle.nosql.spring.data.core.mapping.NosqlId;
import com.oracle.nosql.spring.data.core.mapping.NosqlKey;
import com.oracle.nosql.spring.data.core.mapping.NosqlTable;
import oracle.nosql.driver.Consistency;
import oracle.nosql.driver.Durability;
import oracle.nosql.driver.TimeToLive;
import oracle.nosql.driver.ops.TableLimits;
import oracle.nosql.driver.values.FieldValue;
import org.apache.commons.lang3.reflect.FieldUtils;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.repository.core.support.AbstractEntityInformation;
import org.springframework.data.spel.EvaluationContextProvider;
import org.springframework.data.spel.ExtensionAwareEvaluationContextProvider;
import org.springframework.expression.Expression;
import org.springframework.expression.ParserContext;
import org.springframework.expression.common.LiteralExpression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;

import static com.oracle.nosql.spring.data.Constants.NOTSET_PRIMARY_KEY_ORDER;
import static com.oracle.nosql.spring.data.Constants.NOTSET_SHARD_KEY;

public class NosqlEntityInformation <T, ID> extends
    AbstractEntityInformation<T, ID> {

    private final ApplicationContext applicationContext;
    private final Field id;
    private String tableName;
    private boolean autoCreateTable;
    private TableLimits tableLimits;
    private boolean autoGeneratedId;
    private Consistency consistency;
    private Durability durability;
    private int timeout;
    private final FieldValue.Type idNosqlType;
    private boolean useDefaultTableLimits = false;
    private TimeToLive ttl;
    private Map<String, FieldValue.Type> shardKeys;
    private Map<String, FieldValue.Type> nonShardKeys;

    public NosqlEntityInformation(ApplicationContext applicationContext,
                                  Class<T> domainClass) {
        super(domainClass);

        this.applicationContext = applicationContext;
        this.id = getIdField(domainClass);
        ReflectionUtils.makeAccessible(this.id);
        idNosqlType = findIdNosqlType(getIdType());

        final NosqlId nosqlIdAnn = id.getAnnotation(NosqlId.class);
        if (nosqlIdAnn != null && nosqlIdAnn.generated()) {
            FieldValue.Type nosqlKeyType = getIdNosqlType();
            switch (nosqlKeyType) {
            case LONG:
            case INTEGER:
            case NUMBER:
            case STRING:
                autoGeneratedId = true;
                break;
            default:
                throw new IllegalArgumentException("Type not supported to be " +
                    "autogenerated: " + id.getType() + ". Only int, long, " +
                    "Integer, Long, BigInteger, BigDecimal and String are " +
                    "supported.");
            }
        }

        setTableOptions(domainClass);
    }

    @SuppressWarnings("unchecked")
    @Override
    public ID getId(T entity) {
        return (ID) ReflectionUtils.getField(id, entity);
    }

    public Field getIdField() {
        return this.id;
    }

    public String getIdColumnName() {
        return id.getName();
    }

    @SuppressWarnings("unchecked")
    @Override
    public Class<ID> getIdType() {
        return (Class<ID>) id.getType();
    }

    public FieldValue.Type getIdNosqlType() {
        return idNosqlType;
    }

    public static FieldValue.Type findIdNosqlType(Class<?> idClass) {
        if (idClass == String.class) {
            return FieldValue.Type.STRING;
        }
        if (idClass == int.class || idClass == Integer.class) {
            return FieldValue.Type.INTEGER;
        }
        if (idClass == long.class || idClass == Long.class) {
            return FieldValue.Type.LONG;
        }
        if (idClass == float.class || idClass == Float.class ||
            idClass == double.class || idClass == Double.class) {
            return FieldValue.Type.DOUBLE;
        }
        if (idClass == BigInteger.class || idClass == BigDecimal.class) {
            return FieldValue.Type.NUMBER;
        }
        if (idClass == Timestamp.class || idClass == Date.class || idClass ==
            Instant.class) {
            return FieldValue.Type.TIMESTAMP;
        }
        //Might be composite key. return MAP type
        return FieldValue.Type.MAP;
    }

    public String getTableName() {
        return this.tableName;
    }

    public boolean isAutoCreateTable() {
        return autoCreateTable;
    }

    public boolean isAutoGeneratedId() {
        return autoGeneratedId;
    }

    private Field getIdField(Class<?> domainClass) {
        Field idField;

        final List<Field> idFields = FieldUtils.getFieldsListWithAnnotation(
            domainClass, Id.class);

        if (idFields.isEmpty()) {
            idField = ReflectionUtils.findField(getJavaType(),
                Constants.ID_PROPERTY_NAME);
        } else if (idFields.size() == 1) {
            idField = idFields.get(0);
        } else {
            throw new IllegalArgumentException("Only one field can be with " +
                "@Id annotation in " + domainClass.getName());
        }

        final List<Field> nsFields =
            FieldUtils.getFieldsListWithAnnotation(domainClass, NosqlId.class);

        if (nsFields.size() == 1) {
            idField = nsFields.get(0);
        } else if (nsFields.size() > 1) {
            throw new IllegalArgumentException("Only one field in class " +
                domainClass + " can be with @NosqlId annotation.");
        }

        if (!idFields.isEmpty() && !nsFields.isEmpty()) {
            throw new IllegalArgumentException("Only one of @Id or @NosqlId " +
                "annotation can be used on entity class: " +
                domainClass.getCanonicalName());
        }

        if (idField == null) {
            throw new IllegalArgumentException("Entity should contain @Id or " +
                "@NosqlId annotated field or field named id: " +
                domainClass.getName());
        }
        if (NosqlTemplateBase.JSON_COLUMN.equals(idField.getName())) {
            throw new IllegalArgumentException("Id field can not be named '" +
                NosqlTemplateBase.JSON_COLUMN + "' in " + domainClass.getName());
        }

        //If composite key class check it has only primitive types
        if (isCompositeKeyType(idField.getType())) {
            for (Field primaryKey : idField.getType().getDeclaredFields()) {
                if (!primaryKey.isAnnotationPresent(Transient.class) &&
                        !Modifier.isStatic(primaryKey.getModifiers())) {
                    if (isCompositeKeyType(primaryKey.getType())) {
                        throw new IllegalArgumentException(String.format(
                                "field '%s' must be one of type java.lang" +
                                        ".String," +
                                        " int, java.lang.Integer, long, java" +
                                        ".lang" +
                                        ".Long," +
                                        " java.math.BigInteger, java.math" +
                                        ".BigDecimal," +
                                        " java.sql.Timestamp, java.util.Date " +
                                        "or" +
                                        " java.time.Instant in %s",
                                primaryKey.getName(),
                                idField.getType().getName())
                        );
                    }
                    if (NosqlTemplateBase.JSON_COLUMN.equals(primaryKey.getName())) {
                        throw new IllegalArgumentException("primary key " +
                                "field of the composite key can not be named " +
                                "'" + NosqlTemplateBase.JSON_COLUMN + "' in " +
                                idField.getType().getName());
                    }
                }
            }
        }

        ProcessPrimaryKeys ppKeys = new ProcessPrimaryKeys(idField);
        shardKeys = ppKeys.shardKeys;
        nonShardKeys = ppKeys.nonShardKeys;

        for (String nkey : nonShardKeys.keySet()) {
            for (String sKey : shardKeys.keySet()) {
                if (nkey.equalsIgnoreCase(sKey)) {
                    throw new IllegalArgumentException(String.format(
                            "Conflicting name %s " +
                                    "for primary key in " +
                                    "composite key class " +
                                    "%s", nkey,
                            idField.getType().getName())
                    );
                }
            }
        }
        return idField;
    }

    public static boolean isAllowedKeyType(Class<?> type) {
        return type == String.class ||
                type == Integer.class ||
                type == int.class ||
                type == Long.class ||
                type == long.class ||
                type == Float.class ||
                type == float.class ||
                type == Double.class ||
                type == double.class ||
                type == BigInteger.class ||
                type == BigDecimal.class ||
                type == Timestamp.class ||
                type == Date.class ||
                type == Instant.class;
    }

    public static boolean isCompositeKeyType(Class<?> type) {
        return !isAllowedKeyType(type);
    }

    private void setTableOptions(Class<T> domainClass) {
        autoCreateTable = Constants.DEFAULT_AUTO_CREATE_TABLE;
        tableLimits = null;
        consistency = Consistency.EVENTUAL;
        durability = Durability.COMMIT_NO_SYNC;
        timeout = Constants.NOTSET_TABLE_TIMEOUT_MS;
        tableName = domainClass.getSimpleName();
        if (domainClass.isArray()) {
            tableName = domainClass.getComponentType().getSimpleName() +
                "_Array";
        }

        final NosqlTable annotation =
            domainClass.getAnnotation(NosqlTable.class);

        if (annotation != null) {
            autoCreateTable = annotation.autoCreateTable();

            // If storageGB is 0 or less than -1 no tableLimits are set.
            if (annotation.capacityMode() == NosqlCapacityMode.PROVISIONED &&
               (annotation.storageGB() > 0 || annotation.storageGB() ==
                   Constants.NOTSET_TABLE_STORAGE_GB )) {
                tableLimits = new TableLimits(annotation.readUnits(),
                    annotation.writeUnits(), annotation.storageGB());
            } else if (annotation.capacityMode() == NosqlCapacityMode.ON_DEMAND
                && (annotation.storageGB() > 0  || annotation.storageGB() ==
                Constants.NOTSET_TABLE_STORAGE_GB )) {
                tableLimits = new TableLimits(annotation.storageGB());
            }

            setConsistency(annotation.consistency());
            setDurability(annotation.durability());

            timeout = annotation.timeout();

            if (!annotation.tableName().isEmpty()) {
                tableName = annotation.tableName();

                Environment environment = null;
                if (applicationContext != null) {
                    environment = applicationContext.getEnvironment();
                }

                // to evaluate against application.properties
                if (tableName.contains("$") && environment != null) {
                    tableName = environment.resolvePlaceholders(tableName);
                }

                // to evaluate against SpEl and environment/system properties
                if (tableName.contains("#")) {
                    SpelExpressionParser spelParser =
                        new SpelExpressionParser();
                    Expression expression = spelParser.parseExpression(
                        tableName, ParserContext.TEMPLATE_EXPRESSION);
                    if (!(expression instanceof LiteralExpression)) {
                        EvaluationContextProvider evalCtxProvider =
                            applicationContext != null ?
                            new ExtensionAwareEvaluationContextProvider(
                                applicationContext) :
                            new ExtensionAwareEvaluationContextProvider(
                                Collections.emptyList());
                        tableName = expression.getValue(
                            evalCtxProvider.getEvaluationContext(environment),
                            String.class);
                    }
                }
                if (tableName != null) {
                    tableName = tableName.trim();
                    // Enable "${foo}:Table" or "#{}:Table"
                    if (tableName.startsWith(":")) {
                        tableName = tableName.substring(1);
                    }
                } else {
                    throw new IllegalArgumentException("Table name cannot be " +
                        "null.");
                }
            }

            if (annotation.ttl() < 0) {
                throw new IllegalArgumentException("NosqlTable.ttl cannot be " +
                    "a negative value.");
            }
            ttl = TimeToLive.ofDays(annotation.ttl());
            if (annotation.ttlUnit() == NosqlTable.TtlUnit.HOURS) {
                ttl = TimeToLive.ofHours(annotation.ttl());
            }
        } else {
            // No annotation exists, use the values set in NosqlDbConfig
            useDefaultTableLimits = true;
        }
    }

    private Durability getDurability(String durability) {
        if (durability == null) {
            return Durability.COMMIT_NO_SYNC;
        }
        if ("COMMIT_SYNC".equalsIgnoreCase(durability)) {
            return Durability.COMMIT_SYNC;
        }
        if ("COMMIT_WRITE_NO_SYNC".equalsIgnoreCase(durability)) {
            return Durability.COMMIT_WRITE_NO_SYNC;
        }
        //return COMMIT_NO_SYNC by default
        return Durability.COMMIT_NO_SYNC;
    }

    public TableLimits getTableLimits(NosqlDbFactory nosqlDbFactory) {
        // set table limits for when no annotation exists
        if (useDefaultTableLimits) {
            if (nosqlDbFactory.getDefaultCapacityMode() ==
                NosqlCapacityMode.ON_DEMAND) {
                return new TableLimits(nosqlDbFactory.getDefaultStorageGB());
            } else {
                return new TableLimits(nosqlDbFactory.getDefaultReadUnits(),
                    nosqlDbFactory.getDefaultWriteUnits(),
                    nosqlDbFactory.getDefaultStorageGB());
            }
        }

        if (tableLimits != null) {
            if (tableLimits.getStorageGB() == Constants.NOTSET_TABLE_STORAGE_GB) {
                tableLimits.setStorageGB(nosqlDbFactory.getDefaultStorageGB());
            }
            if (tableLimits.getReadUnits() == Constants.NOTSET_TABLE_READ_UNITS) {
                tableLimits.setReadUnits(nosqlDbFactory.getDefaultReadUnits());
            }
            if (tableLimits.getWriteUnits() == Constants.NOTSET_TABLE_WRITE_UNITS) {
                tableLimits.setWriteUnits(nosqlDbFactory.getDefaultWriteUnits());
            }
        }

        return tableLimits;
    }

    public Consistency getConsistency() {
        return consistency;
    }

    public void setConsistency(String consistency) {
        if (Consistency.ABSOLUTE.getType().toString().equalsIgnoreCase(consistency)) {
            this.consistency = Consistency.ABSOLUTE;
        } else {
            this.consistency = Consistency.EVENTUAL;
        }
    }

    public Durability getDurability() {
        return durability;
    }

    public void setDurability(String durability) {
        this.durability = getDurability(durability);
    }

    public int getTimeout() {
        return timeout;
    }

    public void setTimeout(int milliseconds) {
        if (milliseconds < 0) {
            throw new IllegalArgumentException("Timeout cannot be a negative " +
                "value.");
        }
        timeout = milliseconds;
    }

    /**
     * Get default table level TTL of the entity.
     * This is applicable only when the table is created through Spring SDK
     * as part of  {@link NosqlTable#autoCreateTable()}. This will not reflect
     * the TTL of an already created table.
     *
     * @return Default table level TTL
     *
     * @since 1.5.0
     */
    public TimeToLive getTtl() {
        return ttl;
    }

    public Map<String, FieldValue.Type> getShardKeys() {
        return shardKeys;
    }

    public Map<String, FieldValue.Type> getNonShardKeys() {
        return nonShardKeys;
    }

    private static class ProcessPrimaryKeys {
        private final Map<String, FieldValue.Type> shardKeys;
        private final Map<String, FieldValue.Type> nonShardKeys;

        public ProcessPrimaryKeys(Field idField) {
            shardKeys = new LinkedHashMap<>();
            nonShardKeys = new LinkedHashMap<>();
            process(idField);
        }

        private void process(Field idField) {
            Class<?> idFieldClass = idField.getType();

            if (isCompositeKeyType(idField.getType())) {
                //composite key
                TreeMap<Integer, SortedSet<String>> shardMap = new TreeMap<>();
                TreeMap<Integer, SortedSet<String>> nonShardMap = new TreeMap<>();

                for (Field primaryKey : idField.getType().getDeclaredFields()) {
                    if (!primaryKey.isAnnotationPresent(Transient.class) &&
                            !Modifier.isStatic(primaryKey.getModifiers())) {

                        int order = NOTSET_PRIMARY_KEY_ORDER;
                        boolean isShard = NOTSET_SHARD_KEY;

                        if (primaryKey.isAnnotationPresent(NosqlKey.class)) {
                            NosqlKey nosqlKey =
                                    primaryKey.getAnnotation(NosqlKey.class);
                            order = nosqlKey.order();
                            isShard = nosqlKey.shardKey();
                        }
                        //If shard save in shardMap
                        if (isShard) {
                            SortedSet<String> ss = shardMap.getOrDefault(order,
                                    new TreeSet<>(String.CASE_INSENSITIVE_ORDER));
                            if (ss.contains(primaryKey.getName())) {
                                throw new IllegalArgumentException(
                                        String.format("Conflicting name %s " +
                                                        "for primary key in " +
                                                        "composite key class " +
                                                        "%s",
                                                primaryKey.getName(),
                                                idFieldClass)
                                );
                            }
                            ss.add(primaryKey.getName());
                            shardMap.put(order, ss);
                        } else {
                            //save in nonShardMap
                            SortedSet<String> ss =
                                    nonShardMap.getOrDefault(order,
                                    new TreeSet<>(String.CASE_INSENSITIVE_ORDER));
                            if (ss.contains(primaryKey.getName())) {
                                throw new IllegalArgumentException(
                                        String.format("Conflicting name %s " +
                                                        "for primary key in " +
                                                        "composite key class " +
                                                        "%s",
                                                primaryKey.getName(),
                                                idFieldClass)
                                );
                            }
                            ss.add(primaryKey.getName());
                            nonShardMap.put(order, ss);
                        }
                    }
                }

                List<String> sortedShardKeys = new ArrayList<>();
                List<String> sortedNonShardKeys = new ArrayList<>();

                shardMap.forEach((order, keys) -> {
                    //order should be specified on all fields if at all is used
                    if (order != NOTSET_PRIMARY_KEY_ORDER &&
                            shardMap.get(NOTSET_PRIMARY_KEY_ORDER) != null) {
                        throw new IllegalArgumentException("If order is " +
                                "specified, it must be specified on all key" +
                                " fields of the composite key class " +
                                idField.getType().getName());
                    }

                    //order value must be unique
                    if (order != NOTSET_PRIMARY_KEY_ORDER && keys.size() > 1) {
                        throw new IllegalArgumentException("Order of " +
                                "keys must be unique in composite key " +
                                "class " + idFieldClass.getName());
                    }
                    sortedShardKeys.addAll(keys);
                });

                nonShardMap.forEach((order, keys) -> {
                    //order should be specified on all fields if at all is used
                    if (order != NOTSET_PRIMARY_KEY_ORDER &&
                            nonShardMap.get(NOTSET_PRIMARY_KEY_ORDER) != null) {
                        throw new IllegalArgumentException("If order is " +
                                "specified, it must be specified on all key" +
                                " fields of the composite key class " +
                                idField.getType().getName());
                    }

                    //order value must be unique
                    if (order != NOTSET_PRIMARY_KEY_ORDER && keys.size() > 1) {
                        throw new IllegalArgumentException("Order of " +
                                "keys must be unique in composite key " +
                                "class " + idFieldClass.getName());
                    }
                    sortedNonShardKeys.addAll(keys);
                });

                if (sortedShardKeys.isEmpty()) {
                    throw new IllegalArgumentException("At least one of the " +
                            "@NosqlKey must be shard key in class " +
                            idFieldClass.getName());
                }

                if (!nonShardMap.isEmpty()) {
                    int shardMaxOrder = shardMap.lastKey();
                    int nonShardMinOrder = nonShardMap.firstKey();

                    if (shardMaxOrder != -1 && nonShardMinOrder <= shardMaxOrder) {
                        throw new IllegalArgumentException("Order of non " +
                                "shard " +
                                "keys must be greater than all the shard keys" +
                                " in " +
                                "the composite key class " + idFieldClass.getName());
                    }
                }

                sortedShardKeys.forEach(keyName -> {
                    Field field = ReflectionUtils.findField(idField.getType(),
                            keyName);
                    shardKeys.put(keyName,
                            NosqlEntityInformation.findIdNosqlType(
                                    field.getType()));
                });

                sortedNonShardKeys.forEach(keyName -> {
                    Field field = ReflectionUtils.findField(idField.getType(),
                            keyName);
                    nonShardKeys.put(keyName,
                            NosqlEntityInformation.findIdNosqlType(
                                    field.getType()));
                });
            } else { //simple key
                shardKeys.put(idField.getName(),
                        NosqlEntityInformation.findIdNosqlType(idField.getType())
                );
            }
        }
    }
}
